<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/> 
</head>

<body>



<h1>Case Study: Use of TRIZ in Software Design<font size="3"></font></h1>
<p>

<table align="right" border="0" cellpadding="0" cellspacing="0" width="175">
<tr>
<td rowspan="10" width="15"><img src="http://www.metodolog.ru/triz-journal/library/graphics/clear.gif" width="15" height="1" alt=""></td>
<td>



</td>
</tr>
<tr>
<td height="5"></td>
</tr>
<tr><td>


</td>
</tr>

<tr>
<td height="5"></td>
</tr>

<tr>
<td>
<table bgcolor="#F7941D" border="0" cellpadding="2" cellspacing="0" width="100%">
<tr>
<td>
<table border="0" cellpadding="2" cellspacing="0" width="100%">
<tr>
<td><b><font face="arial,sans-serif" size="2" color="#ffffff">Related Tools &amp;
Articles</font></b></td>
</tr>
</table>
<table bgcolor="#ffcc33" border="0" cellpadding="4" cellspacing="0" width="100%">
<tr>
<td bgcolor="#ffffff">
<table border=0>
 <tr valign='top'><td><li></td><td height='35'>
 
 <div><font face="verdana,geneva,sans-serif" size="1"><a href='http://www.metodolog.ru/triz-journal/archives/2007/02/08/'>Kraev's Korner: System Ideality - Lesson 5</a><br><br></font></div>

</td></tr>

 <tr valign='top'><td><li></td><td height='35'>
 
 <div><font face="verdana,geneva,sans-serif" size="1"><a href='http://www.metodolog.ru/triz-journal/archives/1997/04/b/index.html'>'No-compromise' Design Solutions for Air Bags</a><br><br></font></div>

</td></tr>

 <tr valign='top'><td><li></td><td height='35'>
 
 <div><font face="verdana,geneva,sans-serif" size="1"><a href='http://www.metodolog.ru/triz-journal/archives/1998/10/d/index.htm'>Integrating TRIZ-Based Methods into the Engineering Curriculum</a></font></div>

</td></tr>
</table>
</td>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>

<tr>
<td height="5"></td>
</tr>

<tr>
<td>
<table bgcolor="#000099" border="0" cellpadding="2" cellspacing="0" width="100%">
<tr>
<td>
<table border="0" cellpadding="2" cellspacing="0" width="100%">
<tr>
<td><b><font face="arial,sans-serif" size="2" color="#ffffff">Discussion Forum</b></font></td>
</tr>
</table>
<table bgcolor="#ffcc33" border="0" cellpadding="4" cellspacing="0" width="100%">
<tr>
<td bgcolor="#ffffff">
<font face="verdana,geneva,sans-serif" size="1">&quot;I have never really thought of DFSS (Design for Six Sigma) as the official way to integrate innovation into Six Sigma. DFSS is a means for designing products (and processes) utilizing Six Sigma...&quot;<br><br><a href='http://www.realinnovation.com/forum/showmessage.asp?messageID=1094'>Contribute to this Discussion</a> </font>
</tr>
</table>
</td>
</tr>
</table>
</td>
</tr>

<tr>
<td HEIGHT="5"></td>
</tr>
</table>


</noindexfb><BODYTEXT>
<P>By <A href="#authors">Navneet Bhushan</A></P><P>According to <EM>The Mythical Man-Month</EM>, the essence of software is a construct of interlocking abstract concepts.<SUP><A href="#ref1">1</A></SUP> Complexity, conformity, changeability and invisibility are inherent properties of the essence of software. Given the radical differences in software development in comparison to other engineering disciplines, complexity and changeability assume greater importance. Even the process of creating software makes it prone to complexity. Two main sources of the complexity are functional and structural changes that surface as the system is developed.</P><P>The Theory of Inventive Problem Solving (TRIZ) is a large collection of empirical methods discovered and invented through comprehensive studies of millions of patents and other inventions for problem formulation and possible solution directions.<SUP><A href="#ref2">2</A></SUP>&nbsp;One of the pillars of TRIZ is the quest for ideality. TRIZ forces problem solvers to define the ideal system, which is defined as function achieved without resources or harm. It is extremely useful when it is known what function the system being designed needs to perform. This is fairly easy for a system whose functionality, once defined, will not change – a hardware system is an example.</P><P>By contrast a software system is developed in an evolutionary way – no one knows the final fine-grained functionality of the system upfront. A company starts with one idea and the system typically ends up looking like something else. In this scenario, what is the ideal system? Should the structure of the system be looked at rather than just the function?</P><P>Many different metrics exist for measuring software complexity. Researchers have tried to measure software complexity from the code complexity perspective as well as coupling and cohesion point of view, or even the disorder in the code defined as software entropy.<SUP><A href="#ref3">3</A></SUP> There is work studying relationship between software complexity and software reliability in literature.<SUP><A href="#ref5">5</A>,<A href="#ref7">7</A></SUP>&nbsp;The relationship between software complexity as an interacting process of coupling and cohesion has been studied explicitly.<SUP><A href="#ref4">4</A></SUP> The system complexity estimator (SCE) and system change impact model (SCIM) quantify the structural complexity of the software system.<SUP><A href="#ref16">16</A></SUP></P><P>The author proposes that the ideality of system structure is just as important a constituent in the design of a system as achievement of function, perhaps reflecting the wisdom of ancients, who proclaimed, "It is not only the end but the means as well that matters." By "means," the author is referring to the structure of the system. The author further proposes that ideality should be congruent with simplicity or the least complex software system. This article describes experiments with this line of thinking in a specific scenario – development an identity security software system.</P><H2>Software Complexity Measures</H2><P>In a software system, complexity emanates from the unstructured nature of the software, the gap between actual requirements and those specified, the gap between requirements specification and design, and the gap between design and implementation (the actual code written).<SUP><A href="#ref6">6</A></SUP></P><P>The structure of the software system is composed of multiple elements joined together to provide system-level functionality. The elements can be functions, independent modules, procedures, classes and objects. Their interaction is based on the content that they transfer to each other while the software system is executed. Content may be simple data, data structure, control information, functions or programs. Standard design practice dictates that such coupling should be minimized. Further, each element of the software system should be as cohesive as possible. Complexity emanates from a lack of cohesion in each module and the strength of coupling between various modules.<SUP><A href="#ref9">9</A>,<A href="#ref10">10</A></SUP> </P><P>Modularity is central to the design and development of software. Modular systems incorporate collections of abstractions in which each functional abstraction, each data abstraction and each control abstraction handles a local aspect of the problem being solved.<SUP><A href="#ref9">9</A>,<A href="#ref10">10</A></SUP>&nbsp;The coupling-cohesion criteria mean that the system is structured to maximize the cohesion of elements in each module and to minimize coupling between modules.</P><P>Coupling refers to the degree of interdependence among the components of a software system. Good software should obey the principle of low coupling. The cohesion of a module is defined as a quality attribute that seeks to measure the singleness of purpose of a module. Cohesion seeks to maximize the connections within a module. Composite module cohesion has been quantitatively defined.<SUP><A href="#ref11">11</A></SUP></P><P>A measure of complexity called software entropy takes into account the disorder in the code.<SUP><A href="#ref3">3</A></SUP>&nbsp;The disorder in the system depends upon the lack of cohesion in the modules, level of coupling between modules and complexity of the modules. The Software Engineering Institute (SEI) offers the maintainability index (MI), which states that a program's maintainability is calculated using a combination of widely-used and commonly-available measures.<SUP><A href="#ref8">8</A>,<A href="#ref12">12</A></SUP>&nbsp;Taking a cue from social network analysis, one source defines the system complexity estimator as a measure of complexity of the system.<SUP><A href="#ref16">16</A></SUP>&nbsp;This is an integrated metric that combines coupling and cohesion of various components of a system.</P><H2>The System Complexity Estimator</H2><P>Software system complexity is defined as a measure of the non-cohesion of a system's constituent modules and the interdependencies of modules.<SUP><A href="#ref16">16</A></SUP>&nbsp;This is closer to the design guideline of minimum coupling and maximum cohesion.<SUP><A href="#ref9">9</A>,<A href="#ref10">10</A></SUP>&nbsp;The SCE computes overall complexity of the system using the centrality measures typically used in social network analysis to identify the relative importance of different actors based on their connectivity with the rest of the network.<SUP><A href="#ref6">6</A>,<A href="#ref13">13</A></SUP></P><P>The SCE starts with the definition of an ideal software system: "A system with completely independent elements (modules) where each module performs a single function is the least complex architecture – this is the ideal architecture for a system. In such an ideal architecture/design the system complexity is minimized." Ideally a module should perform only a single function.</P><P>Further, the SCE identifies two levels of complexities – one at the element/module level and another at the level of interdependencies among elements. Non-cohesion is measured by the cardinality of functions performed by each module. The more functions a particular module performs, the less cohesive it is. The second level of complexity is the interdependencies among system elements. There are two kinds of interdependencies: 1) how much the module depends on the system for its functioning and 2) how much the system depends on the module for its functioning. As an example, the dependency matrix in Table 1 describes a four-module software system.</P><P><TABLE cellSpacing=2 cellPadding=2 width="60%" align=center border=1><TBODY><TR><TD bgColor=#000099 colSpan=5><FONT color=#ffffff><STRONG>Table 1:</STRONG> System Dependency Matrix</FONT></TD></TR><TR><TD bgColor=#cccccc><P align=center>&nbsp;</P></TD><TD bgColor=#cccccc><P align=center><STRONG>A1</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A2</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A3</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A4</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A1</STRONG></P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>0.5</P></TD><TD><P align=center>0.0</P></TD><TD><P align=center>0.0</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A2</STRONG></P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>0.8</P></TD><TD><P align=center>0.0</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A3</STRONG></P></TD><TD><P align=center>0.0</P></TD><TD><P align=center>0.5</P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>0.0</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A4</STRONG></P></TD><TD><P align=center>0.2</P></TD><TD><P align=center>0.0</P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>1.0</P></TD></TR></TBODY></TABLE></P><P>Once the dependency matrix (D) and the number of functions performed by each module are obtained, a system complexity matrix (X) can be constructed.<SUP><A href="#ref2">2</A></SUP> Each element of <EM>X</EM>, i.e., <EM>x<SUB>ij</SUB></EM> is computed as:</P><BLOCKQUOTE dir=ltr style="MARGIN-RIGHT: 0px"><P><EM>x<SUB>ij</SUB> = d<SUB>ij</SUB> x H<SUB>j</SUB></EM></P></BLOCKQUOTE><P>where&nbsp;<EM>d<SUB>ij</SUB></EM>&nbsp;is the&nbsp;<EM>i<SUP>th</SUP></EM>&nbsp;row and&nbsp;<EM>j<SUP>th</SUP></EM> column element of matrix D;&nbsp;<EM>H<SUB>j</SUB></EM> is the non-cohesion of module j, which equals the number of functions performed by j;&nbsp;<EM>x<SUB>ij</SUB></EM>&nbsp;is the&nbsp;<EM>i<SUP>th</SUP></EM> row and&nbsp;<EM>j<SUP>th</SUP></EM> column element of matrix X. The system complexity matrix (SCM) for the example above is shown in Table 2.</P><P><TABLE cellSpacing=2 cellPadding=2 width="60%" align=center border=1><TBODY><TR><TD bgColor=#000099 colSpan=5><FONT color=#ffffff><STRONG>Table 2:</STRONG> System Complexity Matrix</FONT></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Non-cohesion</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>3</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>2</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>1</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>6</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG></STRONG>&nbsp;</P></TD><TD bgColor=#cccccc><P align=center><STRONG>A1</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A2</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A3</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A4</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A1</STRONG></P></TD><TD><P align=center>3.0</P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>0.0</P></TD><TD><P align=center>0.0</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A2</STRONG></P></TD><TD><P align=center>3.0</P></TD><TD><P align=center>2.0</P></TD><TD><P align=center>0.8</P></TD><TD><P align=center>0.0</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A3</STRONG></P></TD><TD><P align=center>0.0</P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>0.0</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A4</STRONG></P></TD><TD><P align=center>0.6</P></TD><TD><P align=center>0.0</P></TD><TD><P align=center>1.0</P></TD><TD><P align=center>6.0</P></TD></TR></TBODY></TABLE></P><P>The overall system complexity (<FONT face=Symbol>W</FONT>) is the sum of all elements of matrix. Table 2 totals 19.4. To find out the relative contribution of each module to the overall complexity, take into account the dependencies in more detail.</P><P>There are two kinds of dependency mapping to compute the two corresponding indices. These indices are called module dependency on the system index (MDSI) and system dependency on the module index (SDMI). The corresponding element of the normalized eigenvector corresponding to the principal eigenvalue of the SCM gives the MDSI for the respective module. Similarly, the element of the vector obtained for the transposition of the SCM gives the SDMI. The MDSI for the X matrix is given in Table 3. Similar computations for the transposing of the matrix will lead to SDMI – these values are shown in Table 4.</P><P><TABLE cellSpacing=2 cellPadding=2 width="60%" align=center border=1><TBODY><TR><TD bgColor=#000099 colSpan=6><FONT color=#ffffff><STRONG>Table 3:</STRONG> Normalized Eigenvector Corresponding to Principal Eigenvalue</FONT></TD></TR><TR><TD bgColor=#cccccc><P align=center>&nbsp;</P></TD><TD bgColor=#cccccc><P align=center><STRONG>A1</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A2</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A3</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>A4</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>MDSI</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A1</STRONG></P></TD><TD><P align=center>0.45</P></TD><TD><P align=center>0.25</P></TD><TD><P align=center>0.00</P></TD><TD><P align=center>0.00</P></TD><TD><P align=center>0.18</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A2</STRONG></P></TD><TD><P align=center>0.45</P></TD><TD><P align=center>0.50</P></TD><TD><P align=center>0.29</P></TD><TD><P align=center>0.00</P></TD><TD><P align=center>0.31</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A3</STRONG></P></TD><TD><P align=center>0.00</P></TD><TD><P align=center>0.25</P></TD><TD><P align=center>0.36</P></TD><TD><P align=center>0.00</P></TD><TD><P align=center>0.15</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A4</STRONG></P></TD><TD><P align=center>0.09</P></TD><TD><P align=center>0.00</P></TD><TD><P align=center>0.36</P></TD><TD><P align=center>1.00</P></TD><TD><P align=center>0.36</P></TD></TR></TBODY></TABLE></P><P><TABLE cellSpacing=2 cellPadding=2 width="60%" align=center border=1><TBODY><TR><TD bgColor=#000099 colSpan=5><FONT color=#ffffff><STRONG>Table 4:</STRONG> Relative Contribution of Modules to System Complexity</FONT></TD></TR><TR><TD bgColor=#cccccc><P align=center>&nbsp;</P></TD><TD bgColor=#cccccc><P align=center><STRONG>MDSI</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>SDMI</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>Average (r)</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>Module Complexity (r x <FONT face=Symbol>W</FONT>)</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A1</STRONG></P></TD><TD><P align=center>&nbsp;0.18</P></TD><TD><P align=center>&nbsp;0.34</P></TD><TD><P align=center>&nbsp;0.26</P></TD><TD><P align=center>&nbsp;4.97</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A2</STRONG></P></TD><TD><P align=center>&nbsp;0.31</P></TD><TD><P align=center>&nbsp;0.27</P></TD><TD><P align=center>&nbsp;0.29</P></TD><TD><P align=center>&nbsp;5.66</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A3</STRONG></P></TD><TD><P align=center>&nbsp;0.15</P></TD><TD><P align=center>&nbsp;0.19</P></TD><TD><P align=center>&nbsp;0.17</P></TD><TD><P align=center>&nbsp;3.34</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>A4</STRONG></P></TD><TD><P align=center>&nbsp;0.36</P></TD><TD><P align=center>&nbsp;0.20</P></TD><TD><P align=center>&nbsp;0.28</P></TD><TD><P align=center>&nbsp;5.43</P></TD></TR></TBODY></TABLE></P><P>Table 4 shows that the average of MDSI and SDMI gives the relative contribution of a given module to overall system complexity in percentages. Multiplying these percentages (r) by the overall system complexity (C) results in the module complexity. Modules A1, A2, A3 and A4 contribute 4.97, 5.66, 3.34 and 5.43 to the overall complexity, respectively.</P><P>A radar plot or Kiviat chart showing the complexity contribution of each module provides a system complexity map of the software design, which is useful in finding complexity imbalances in the software system. The SCE-SCIM framework has been used to describe an approach for a robust inventive software design, which combines the analytic hierarchy process (AHP) TRIZ and DSM as an integrated framework.<SUP><A href="#ref14">14</A>,<A href="#ref15">15</A></SUP></P><H2>Identity Security Software Product Design Case Study</H2><P>Akiva is a data scrambling tool to mask enterprise database applications. It is designed to "de-identify" personal and sensitive data required for use in a variety of situations such as software development, implementation and testing and outsourcing. It allows the creation of disguised copies of production databases and provides realistic and fully functional databases without compromising privacy, and offers an additional level of data protection beyond firewalls and encryption. Its main features include:</P><UL><LI>Data consistency: Akiva masks data consistently across PeopleSoft applications, so that the same entity relationship is maintained post-masking. <LI>Ability to choose any data element: It enables data security officers to choose any of the sensitive data elements from PeopleSoft applications online using Akiva. This includes vanilla and customized components. <LI>Data security: The data masking algorithm isn't static in nature, Akiva accepts unique a 16-digit numeric token key as input for masking. <LI>Wide coverage: Akiva supports all modules and pillars for PeopleSoft. Data security officers can use the same tool to mask sensitive information in their human resources, payroll, benefits, supply chain management and financial applications. <LI>Data integrity: Akiva masks PeopleSoft enterprise data without affecting any of the business process validations. <LI>Secure: Akiva does not store any of the masking information, including the token key in the system.</LI></UL><P>The algorithms that Akiva implements include:</P><UL><LI>Scramble: to arithmetically generate new values in required field format based on the input token key <LI>Combo shuffle: to join group fields and shuffle them based on a lookup table <LI>Selective shuffle: to replace sensitive values with meaningful, readable data based on a lookup table. Shuffle is based on a selection criteria, such as "shuffle female names and male names separately." <LI>Replacement: to replace a field value with a static value provided <LI>Blank out: to replace a field value with a static value <LI>Lookup: to replace employee names and addresses from an inbuilt repository <LI>SSN generator: to generate valid Social Security numbers (SSN) for all employees <LI>Luhn generator: to generate numbers satisfying the Luhn checksum condition <LI>Pattern generator: to generate a set of numbers based on a user-defined pattern</LI></UL><P>The web-based application has been developed using the J2EE framework. The masking algorithms have been implemented using PL/SQL procedures in Oracle.</P><H2>Evolution Toward Ideality</H2><P>The existing Akiva design has an estimated 8,000 lines of code, with 18 modules performing a total of 54 unique functions; the average number of functions per module is three. The SCE established that the system complexity was 88.7. (The system complexity map is shown in Figure 1.)</P><P><TABLE cellSpacing=0 cellPadding=1 align=center bgColor=#001894 border=0><TBODY><TR><TD align=middle><TABLE cellSpacing=0 cellPadding=0 border=0><TBODY><TR align=middle><TD vAlign=top><TABLE cellSpacing=0 cellPadding=0 bgColor=#001894 border=0><TBODY><TR><TD colSpan=2><TABLE cellSpacing=0 cellPadding=2 border=0><TBODY><TR><TD align=left><FONT face=arial color=#ffffff size=-1>&nbsp;<B>Figure 1:</B> System Complexity Map for Existing Akiva Design</FONT></TD></TR></TBODY></TABLE></TD></TR><TR bgColor=#ffffff><TD align=middle><FONT size=+0><IMG height=213 alt="" src="http://www.metodolog.ru/triz-journal/library/graphics/2008-06-nb01.gif" width=367 border=0></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></P><P>The blue area highlights the complexity imbalance created by the module "Masking," which contributes the most to the overall complexity. In the ideal system, the complexity should be equivalent to the number of functions being performed, which is 54.</P><P>The team brainstormed to look at alternative designs for minimizing the system complexity. Three alternative designs evolved as shown in Figures 2, 3 and 4. The first has 22 modules, the second has 39 modules and the third has 42 modules.</P><P><TABLE cellSpacing=0 cellPadding=1 align=center bgColor=#001894 border=0><TBODY><TR><TD align=middle><TABLE cellSpacing=0 cellPadding=0 border=0><TBODY><TR align=middle><TD vAlign=top><TABLE cellSpacing=0 cellPadding=0 bgColor=#001894 border=0><TBODY><TR><TD colSpan=2><TABLE cellSpacing=0 cellPadding=2 border=0><TBODY><TR><TD align=left><FONT face=arial color=#ffffff size=-1>&nbsp;<B>Figure 2:</B> Design Option 1 with 22 Modules</FONT></TD></TR></TBODY></TABLE></TD></TR><TR bgColor=#ffffff><TD align=middle><FONT style="BACKGROUND-COLOR: #ffffff"><IMG height=213 alt="" src="http://www.metodolog.ru/triz-journal/library/graphics/2008-06-nb02.gif" width=452 border=0></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></P><P><TABLE cellSpacing=0 cellPadding=1 align=center bgColor=#001894 border=0><TBODY><TR><TD align=middle><TABLE cellSpacing=0 cellPadding=0 border=0><TBODY><TR align=middle><TD vAlign=top><TABLE cellSpacing=0 cellPadding=0 bgColor=#001894 border=0><TBODY><TR><TD colSpan=2><TABLE cellSpacing=0 cellPadding=2 border=0><TBODY><TR><TD align=left><FONT face=arial color=#ffffff size=-1>&nbsp;<B>Figure 3:</B> Design Option 2 with 39 Modules</FONT></TD></TR></TBODY></TABLE></TD></TR><TR bgColor=#ffffff><TD align=middle><FONT style="BACKGROUND-COLOR: #ffffff"><IMG height=213 alt="" src="http://www.metodolog.ru/triz-journal/library/graphics/2008-06-nb03.gif" width=420 border=0></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></P><P><TABLE cellSpacing=0 cellPadding=1 align=center bgColor=#001894 border=0><TBODY><TR><TD align=middle><TABLE cellSpacing=0 cellPadding=0 border=0><TBODY><TR align=middle><TD vAlign=top><TABLE cellSpacing=0 cellPadding=0 bgColor=#001894 border=0><TBODY><TR><TD colSpan=2><TABLE cellSpacing=0 cellPadding=2 border=0><TBODY><TR><TD align=left><FONT face=arial color=#ffffff size=-1>&nbsp;<B>Figure 4:</B> Design Option 3 with 42 Modules</FONT></TD></TR></TBODY></TABLE></TD></TR><TR bgColor=#ffffff><TD align=middle><FONT style="BACKGROUND-COLOR: #ffffff"><IMG height=329 alt="" src="http://www.metodolog.ru/triz-journal/library/graphics/2008-06-nb04.gif" width=575 border=0></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></P><P>As the number of modules increased, the functions per module decreased – 3, 1.3 and 1.2, respectively. Compared to the existing design, this was definitely an improvement. However, overall complexity of the product in all three design options actually increased because of the increased number of couplings among various modules – to 102, 174 and 155, respectively.</P><H2>A Design Nearer to Ideality</H2><P>The team brainstormed further to look at ways and means of reducing the coupling. It hit upon the idea of a router, which was suggested earlier during the discussions but not pursued. In networking, a router is a device (usually hardware but sometimes software) that determines where a given packet should head next, based on its knowledge of the state of the network at any given moment. By applying this concept, the team derived a design (shown in Figure 5) with 36 modules performing 45 functions, which equals 1.3 functions per module. The overall complexity decreased to 81 from 89 in the original design. This is a much cleaner design and easier to maintain.</P><P><TABLE cellSpacing=0 cellPadding=1 align=center bgColor=#001894 border=0><TBODY><TR><TD align=middle><TABLE cellSpacing=0 cellPadding=0 border=0><TBODY><TR align=middle><TD vAlign=top><TABLE cellSpacing=0 cellPadding=0 bgColor=#001894 border=0><TBODY><TR><TD colSpan=2><TABLE cellSpacing=0 cellPadding=2 border=0><TBODY><TR><TD align=left><FONT face=arial color=#ffffff size=-1>&nbsp;<B>Figure 5:</B> The Final Evolved Design</FONT></TD></TR></TBODY></TABLE></TD></TR><TR bgColor=#ffffff><TD align=middle><FONT style="BACKGROUND-COLOR: #ffffff"><IMG height=329 alt="" src="http://www.metodolog.ru/triz-journal/library/graphics/2008-06-nb05.gif" width=575 border=0></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></P><P>The most useful result, however, is a reduction in the lines of code from 7,964 to 3,866 – more than 50 percent. Table 5 shows the lines of code in the modules of the original design and those in the final evolved design.</P><P><TABLE cellSpacing=2 cellPadding=2 width="60%" align=center border=1><TBODY><TR><TD bgColor=#000099 colSpan=3><FONT color=#ffffff><STRONG>Table 5:</STRONG> A Comparison of Lines of Code</FONT></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Algorithm</STRONG></P></TD><TD bgColor=#cccccc colSpan=2><P align=center><STRONG>Lines of Code</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG></STRONG>&nbsp;</P></TD><TD bgColor=#cccccc><P align=center><STRONG>Before</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>After</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Blank out</STRONG></P></TD><TD><P align=center>562</P></TD><TD><P align=center>109</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Replacement</STRONG></P></TD><TD><P align=center>575</P></TD><TD><P align=center>122</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Generic shuffle</STRONG></P></TD><TD><P align=center>1,435</P></TD><TD><P align=center>211</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>SSN generator</STRONG></P></TD><TD><P align=center>1,812</P></TD><TD><P align=center>542</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Scrambling</STRONG></P></TD><TD><P align=center>2,453</P></TD><TD><P align=center>974</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>LUHN</STRONG></P></TD><TD><P align=center>1,127</P></TD><TD><P align=center>168</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Log</STRONG></P></TD><TD><P align=center>0</P></TD><TD><P align=center>150</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Single field router</STRONG></P></TD><TD><P align=center>0</P></TD><TD><P align=center>1,590</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>TOTAL</STRONG></P></TD><TD><P align=center>7,964</P></TD><TD><P align=center>3,866</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>DIFFERENCE</STRONG></P></TD><TD><P align=center>-</P></TD><TD><P align=center>-4,098</P></TD></TR></TBODY></TABLE></P><P>The table below summarizes the system complexity analysis of existing, alternatives design options and final evolved design. The final evolved design is not only closer to design guideline of highly cohesive modules but also coupled to the optimal need.</P><P><TABLE cellSpacing=2 cellPadding=2 width="60%" align=center border=1><TBODY><TR><TD bgColor=#000099 colSpan=5><FONT color=#ffffff><STRONG>Table 6:</STRONG> A Comparison of Size Design Evaluation</FONT></TD></TR><TR><TD bgColor=#cccccc><P align=center>&nbsp;</P></TD><TD bgColor=#cccccc><P align=center><STRONG>Number of Functions</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>Number of Modules</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>Average Functions/Modules</STRONG></P></TD><TD bgColor=#cccccc><P align=center><STRONG>Complexity</STRONG></P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Existing Design</STRONG></P></TD><TD><P align=center>54</P></TD><TD><P align=center>18</P></TD><TD><P align=center>3</P></TD><TD><P align=center>88.7</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Design Option 1</STRONG></P></TD><TD><P align=center>66</P></TD><TD><P align=center>22</P></TD><TD><P align=center>3</P></TD><TD><P align=center>102.3</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Design Option 2</STRONG></P></TD><TD><P align=center>51</P></TD><TD><P align=center>39</P></TD><TD><P align=center>1.3</P></TD><TD><P align=center>174</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Design Option 3</STRONG></P></TD><TD><P align=center>51</P></TD><TD><P align=center>42</P></TD><TD><P align=center>1.2</P></TD><TD><P align=center>154.6</P></TD></TR><TR><TD bgColor=#cccccc><P align=center><STRONG>Final Evolved Design</STRONG></P></TD><TD><P align=center>45</P></TD><TD><P align=center>36</P></TD><TD><P align=center>1.3</P></TD><TD><P align=center>81.2</P></TD></TR></TBODY></TABLE></P><P>Figure 6 plots system complexity for all of the designs. The evolved design of Akiva has least complexity. The bubble size of each design option indicates the average cohesion as defined by the number of functions per module.</P><P><TABLE cellSpacing=0 cellPadding=1 align=center bgColor=#001894 border=0><TBODY><TR><TD align=middle><TABLE cellSpacing=0 cellPadding=0 border=0><TBODY><TR align=middle><TD vAlign=top><TABLE cellSpacing=0 cellPadding=0 bgColor=#001894 border=0><TBODY><TR><TD colSpan=2><TABLE cellSpacing=0 cellPadding=2 border=0><TBODY><TR><TD align=left><FONT face=arial color=#ffffff size=-1>&nbsp;<B>Figure 6:</B> System Complexity for All Designs</FONT></TD></TR></TBODY></TABLE></TD></TR><TR bgColor=#ffffff><TD align=middle><FONT style="BACKGROUND-COLOR: #ffffff"><IMG height=177 alt="" src="http://www.metodolog.ru/triz-journal/library/graphics/2008-06-nb06.gif" width=369 border=0></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></P><H2>The Work Continues!</H2><P>Using the ideality concept objective from TRIZ, the author proposes that it makes more sense to look at structural ideality than just achievement of function alone for software systems. The system complexity estimator was used for evaluating various design alternatives to evolve to a final software system that was closer to ideality. This approach not only produced a more robust and maintainable software product, it reduced the code size by more than half. This is a highly desirable result since the demands on software development productivity are intensifying. Further, the SCE framework can be used to minimize the complexity of other non-software products.</P><H2>References</H2><OL><LI><A name=ref1></A>Brooks Fred P., <EM>The Mythical Man-Month &#150; Essays on Software Engineering</EM>, Addison Wesley, 1995.<LI><A name=ref2></A>Bhushan, N., "Set-Based Concurrent Engineering and TRIZ – A Framework for Global Product Development," The Alsthuller Institute, <A href="http://www.aitriz.org/ai/articles/InsideTRIZ/0607.pdf.">http://www.aitriz.org/ai/articles/InsideTRIZ/0607.pdf.</A><LI><A name=ref3></A>Bhushan, N. and V. Kaushik, "Software Entropy – Definition and Applications," Workshop Series on Empirical Software Engineering, 2003.<LI><A name=ref4></A>Darcy D.P. et al, The Structural Complexity of Software: Testing the Interaction of Coupling and Cohesion, <A href="http://littlehurt.gsia.cmu&#46;&#101;&#100;&#117;/gsiadoc/WP/2005-E23.pdf.">http://littlehurt.gsia.cmu&#46;&#101;&#100;&#117;/gsiadoc/WP/2005-E23.pdf.</A><LI><A name=ref5></A>Lew, K.S., T.S. Dillon and K.E. Forward, "Software Complexity and Its impact of Software Reliability," IEEE Transactions on Software Engineering, Vol 14., No. 11, November 1998.<LI><A name=ref6></A>Tran-Cao D., A. Abran and G. Levesque, "Functional Complexity Measurement," Proceedings of International Workshop on Software Measurement, August 2001.<LI><A name=ref7></A>Bhushan N., "Balancing Reliability and Software Complexity – Can TRIZ Help?" International Conference on Quality, Reliability and Information Technology (ICQRIT), December 2003.<LI><A name=ref8></A>Software Engineering Institute, Carnegie Mellon, <A href="http://www.sei.cmu&#46;&#101;&#100;&#117;.">http://www.sei.cmu&#46;&#101;&#100;&#117;.</A><LI><A name=ref9></A>Fairley, R., <EM>Software Engineering Concepts</EM>, McGraw Hill, 1985.<LI><A name=ref10></A>Shooman, M.L., <EM>Software Engineering</EM>, McGraw Hill, 1983.<LI><A name=ref11></A>Patel S., Chu W., and R. Baxter, "A Measure of Composite Module Cohesion," ACM Conference, 1992.<LI><A name=ref12></A>Software Engineering Institute, Carnegie Mellon, "Maintainability Index Technique for Measuring Program Maintainability," <A href="http://www.sei.cmu&#46;&#101;&#100;&#117;/str/descriptions/mitmpm.html.">http://www.sei.cmu&#46;&#101;&#100;&#117;/str/descriptions/mitmpm.html.</A><LI><A name=ref13></A>Bonacich, P.B., "Power and Centrality: A Family of Measures," <EM>American Journal of Sociology</EM>, 1987.<LI><A name=ref14></A>Bhushan, N. and K. Rai, <EM>Strategic Decision Making: Applying the Analytic Hierarchy Process</EM>, Springer UK, 2004.<LI><A name=ref15></A>Bhushan, N., "Robust Inventive Software Design (RISD) – A Framework Combining DSM, TRIZ and AHP," <A href="http://www.dsmweb.org/workshops/DSM2005/dsm05conf/presentations/day_3/01_Day3_Navneet_Bhushan.pdf.">http://www.dsmweb.org/workshops/DSM2005/dsm05conf/presentations/day_3/01_Day3_Navneet_Bhushan.pdf.</A><LI><A name=ref16></A>Bhushan N., "System Complexity Estimator – Applications in Software Architecture, Design and Project Planning," The Third International Conference on Quality, Reliability, Infocom Technology, ICQRIT, December 2006, New Delhi, India.</LI></OL><P><FONT size=2><EM>Note: This paper was originally presented at The Altshuller Institute's TRIZCON2008.</EM></FONT></P><H3><A name=authors></a>About the Author:</H3> <p>Navneet Bhushan is the founder / director of an innovation co-creating firm, Crafitti Consulting Pvt Ltd. He has worked close to two decades in managing and developing IT, innovation and productivity solutions and has worked in large commercial and government organizations. He is the principal author of Strategic Decision Making - Applying the Analytic Hierarchy Process published by Springer, UK, 2004. His current research interests include complexity, open innovation and globalization. He is a visiting faculty member at Welingkar School of Business Management. Contact Navneet Bhushan at <a href="javascript:sendmail('navneet.bhushan','crafitti.com');">navneet.bhushan (at) crafitti.com</a> or visit <a href="http://www.crafitti.com" rel="nofollow">http://www.crafitti.com</a>.</p></P><center><table border="0"><tr><td>

</td></tr></table></center>

</b><center>Copyright &copy; 2006-2011
			&#8211; RealInnovation.com, CTQ Media. All Rights Reserved<br>
			Reproduction Without Permission Is Strictly Prohibited &#8211; <a href="http://www.triz-journal.com/uagree/licensing.asp">
			Request Permission</a></center>
<p><hr size=1 color='#000000' width='50%' align=left><font color='#000000'><b>
			Publish an Article</font>: Do you have a innovation
			tip, learning or case study?</b><br><span class='HL2'>Share it</a>
			with the largest community of Innovation
			professionals, and be recognized by your peers.</span><br>It's a
			great way to promote your expertise and/or build your resume. <a href="/submit/">
			Read more about submitting an article</a>.</p>

</BODYTEXT>



</body>
</html>